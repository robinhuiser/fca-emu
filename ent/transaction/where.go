// Code generated by entc, DO NOT EDIT.

package transaction

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
	"github.com/robinhuiser/fca-emu/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// SequenceInDay applies equality check predicate on the "sequenceInDay" field. It's identical to SequenceInDayEQ.
func SequenceInDay(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSequenceInDay), v))
	})
}

// ExecutedAmount applies equality check predicate on the "executedAmount" field. It's identical to ExecutedAmountEQ.
func ExecutedAmount(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedCurrencyCode applies equality check predicate on the "executedCurrencyCode" field. It's identical to ExecutedCurrencyCodeEQ.
func ExecutedCurrencyCode(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExchangeRate applies equality check predicate on the "exchangeRate" field. It's identical to ExchangeRateEQ.
func ExchangeRate(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExchangeRate), v))
	})
}

// OriginatingAmount applies equality check predicate on the "originatingAmount" field. It's identical to OriginatingAmountEQ.
func OriginatingAmount(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingCurrencyCode applies equality check predicate on the "originatingCurrencyCode" field. It's identical to OriginatingCurrencyCodeEQ.
func OriginatingCurrencyCode(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// RunningBalance applies equality check predicate on the "runningBalance" field. It's identical to RunningBalanceEQ.
func RunningBalance(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRunningBalance), v))
	})
}

// CreatedDate applies equality check predicate on the "createdDate" field. It's identical to CreatedDateEQ.
func CreatedDate(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedDate), v))
	})
}

// PostedDate applies equality check predicate on the "postedDate" field. It's identical to PostedDateEQ.
func PostedDate(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPostedDate), v))
	})
}

// ExecutedDate applies equality check predicate on the "executedDate" field. It's identical to ExecutedDateEQ.
func ExecutedDate(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExecutedDate), v))
	})
}

// UpdatedDate applies equality check predicate on the "updatedDate" field. It's identical to UpdatedDateEQ.
func UpdatedDate(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedDate), v))
	})
}

// Description applies equality check predicate on the "description" field. It's identical to DescriptionEQ.
func Description(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescription), v))
	})
}

// Memo applies equality check predicate on the "memo" field. It's identical to MemoEQ.
func Memo(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMemo), v))
	})
}

// Group applies equality check predicate on the "group" field. It's identical to GroupEQ.
func Group(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGroup), v))
	})
}

// Type applies equality check predicate on the "type" field. It's identical to TypeEQ.
func Type(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// MainCategory applies equality check predicate on the "mainCategory" field. It's identical to MainCategoryEQ.
func MainCategory(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMainCategory), v))
	})
}

// SubCategory applies equality check predicate on the "subCategory" field. It's identical to SubCategoryEQ.
func SubCategory(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSubCategory), v))
	})
}

// CheckNumber applies equality check predicate on the "checkNumber" field. It's identical to CheckNumberEQ.
func CheckNumber(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckNumber), v))
	})
}

// Latitude applies equality check predicate on the "latitude" field. It's identical to LatitudeEQ.
func Latitude(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLatitude), v))
	})
}

// Longitude applies equality check predicate on the "longitude" field. It's identical to LongitudeEQ.
func Longitude(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLongitude), v))
	})
}

// MerchantCode applies equality check predicate on the "merchantCode" field. It's identical to MerchantCodeEQ.
func MerchantCode(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMerchantCode), v))
	})
}

// Reversal applies equality check predicate on the "reversal" field. It's identical to ReversalEQ.
func Reversal(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversal), v))
	})
}

// ReversalFor applies equality check predicate on the "reversalFor" field. It's identical to ReversalForEQ.
func ReversalFor(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversalFor), v))
	})
}

// Reversed applies equality check predicate on the "reversed" field. It's identical to ReversedEQ.
func Reversed(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversed), v))
	})
}

// ReversedBy applies equality check predicate on the "reversedBy" field. It's identical to ReversedByEQ.
func ReversedBy(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversedBy), v))
	})
}

// URL applies equality check predicate on the "url" field. It's identical to URLEQ.
func URL(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldURL), v))
	})
}

// SequenceInDayEQ applies the EQ predicate on the "sequenceInDay" field.
func SequenceInDayEQ(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSequenceInDay), v))
	})
}

// SequenceInDayNEQ applies the NEQ predicate on the "sequenceInDay" field.
func SequenceInDayNEQ(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSequenceInDay), v))
	})
}

// SequenceInDayIn applies the In predicate on the "sequenceInDay" field.
func SequenceInDayIn(vs ...int) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSequenceInDay), v...))
	})
}

// SequenceInDayNotIn applies the NotIn predicate on the "sequenceInDay" field.
func SequenceInDayNotIn(vs ...int) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSequenceInDay), v...))
	})
}

// SequenceInDayGT applies the GT predicate on the "sequenceInDay" field.
func SequenceInDayGT(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSequenceInDay), v))
	})
}

// SequenceInDayGTE applies the GTE predicate on the "sequenceInDay" field.
func SequenceInDayGTE(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSequenceInDay), v))
	})
}

// SequenceInDayLT applies the LT predicate on the "sequenceInDay" field.
func SequenceInDayLT(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSequenceInDay), v))
	})
}

// SequenceInDayLTE applies the LTE predicate on the "sequenceInDay" field.
func SequenceInDayLTE(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSequenceInDay), v))
	})
}

// SequenceInDayIsNil applies the IsNil predicate on the "sequenceInDay" field.
func SequenceInDayIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSequenceInDay)))
	})
}

// SequenceInDayNotNil applies the NotNil predicate on the "sequenceInDay" field.
func SequenceInDayNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSequenceInDay)))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v Status) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v Status) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...Status) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatus), v...))
	})
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...Status) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatus), v...))
	})
}

// ExecutedAmountEQ applies the EQ predicate on the "executedAmount" field.
func ExecutedAmountEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedAmountNEQ applies the NEQ predicate on the "executedAmount" field.
func ExecutedAmountNEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedAmountIn applies the In predicate on the "executedAmount" field.
func ExecutedAmountIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExecutedAmount), v...))
	})
}

// ExecutedAmountNotIn applies the NotIn predicate on the "executedAmount" field.
func ExecutedAmountNotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExecutedAmount), v...))
	})
}

// ExecutedAmountGT applies the GT predicate on the "executedAmount" field.
func ExecutedAmountGT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedAmountGTE applies the GTE predicate on the "executedAmount" field.
func ExecutedAmountGTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedAmountLT applies the LT predicate on the "executedAmount" field.
func ExecutedAmountLT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedAmountLTE applies the LTE predicate on the "executedAmount" field.
func ExecutedAmountLTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExecutedAmount), v))
	})
}

// ExecutedCurrencyCodeEQ applies the EQ predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeNEQ applies the NEQ predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeIn applies the In predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExecutedCurrencyCode), v...))
	})
}

// ExecutedCurrencyCodeNotIn applies the NotIn predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExecutedCurrencyCode), v...))
	})
}

// ExecutedCurrencyCodeGT applies the GT predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeGTE applies the GTE predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeLT applies the LT predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeLTE applies the LTE predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeContains applies the Contains predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeHasPrefix applies the HasPrefix predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeHasSuffix applies the HasSuffix predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeEqualFold applies the EqualFold predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExecutedCurrencyCodeContainsFold applies the ContainsFold predicate on the "executedCurrencyCode" field.
func ExecutedCurrencyCodeContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldExecutedCurrencyCode), v))
	})
}

// ExchangeRateEQ applies the EQ predicate on the "exchangeRate" field.
func ExchangeRateEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateNEQ applies the NEQ predicate on the "exchangeRate" field.
func ExchangeRateNEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateIn applies the In predicate on the "exchangeRate" field.
func ExchangeRateIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExchangeRate), v...))
	})
}

// ExchangeRateNotIn applies the NotIn predicate on the "exchangeRate" field.
func ExchangeRateNotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExchangeRate), v...))
	})
}

// ExchangeRateGT applies the GT predicate on the "exchangeRate" field.
func ExchangeRateGT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateGTE applies the GTE predicate on the "exchangeRate" field.
func ExchangeRateGTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateLT applies the LT predicate on the "exchangeRate" field.
func ExchangeRateLT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExchangeRate), v))
	})
}

// ExchangeRateLTE applies the LTE predicate on the "exchangeRate" field.
func ExchangeRateLTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExchangeRate), v))
	})
}

// OriginatingAmountEQ applies the EQ predicate on the "originatingAmount" field.
func OriginatingAmountEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingAmountNEQ applies the NEQ predicate on the "originatingAmount" field.
func OriginatingAmountNEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingAmountIn applies the In predicate on the "originatingAmount" field.
func OriginatingAmountIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOriginatingAmount), v...))
	})
}

// OriginatingAmountNotIn applies the NotIn predicate on the "originatingAmount" field.
func OriginatingAmountNotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOriginatingAmount), v...))
	})
}

// OriginatingAmountGT applies the GT predicate on the "originatingAmount" field.
func OriginatingAmountGT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingAmountGTE applies the GTE predicate on the "originatingAmount" field.
func OriginatingAmountGTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingAmountLT applies the LT predicate on the "originatingAmount" field.
func OriginatingAmountLT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingAmountLTE applies the LTE predicate on the "originatingAmount" field.
func OriginatingAmountLTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOriginatingAmount), v))
	})
}

// OriginatingCurrencyCodeEQ applies the EQ predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeNEQ applies the NEQ predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeIn applies the In predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOriginatingCurrencyCode), v...))
	})
}

// OriginatingCurrencyCodeNotIn applies the NotIn predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOriginatingCurrencyCode), v...))
	})
}

// OriginatingCurrencyCodeGT applies the GT predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeGTE applies the GTE predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeLT applies the LT predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeLTE applies the LTE predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeContains applies the Contains predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeHasPrefix applies the HasPrefix predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeHasSuffix applies the HasSuffix predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeEqualFold applies the EqualFold predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// OriginatingCurrencyCodeContainsFold applies the ContainsFold predicate on the "originatingCurrencyCode" field.
func OriginatingCurrencyCodeContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOriginatingCurrencyCode), v))
	})
}

// DirectionEQ applies the EQ predicate on the "direction" field.
func DirectionEQ(v Direction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDirection), v))
	})
}

// DirectionNEQ applies the NEQ predicate on the "direction" field.
func DirectionNEQ(v Direction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDirection), v))
	})
}

// DirectionIn applies the In predicate on the "direction" field.
func DirectionIn(vs ...Direction) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDirection), v...))
	})
}

// DirectionNotIn applies the NotIn predicate on the "direction" field.
func DirectionNotIn(vs ...Direction) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDirection), v...))
	})
}

// RunningBalanceEQ applies the EQ predicate on the "runningBalance" field.
func RunningBalanceEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRunningBalance), v))
	})
}

// RunningBalanceNEQ applies the NEQ predicate on the "runningBalance" field.
func RunningBalanceNEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRunningBalance), v))
	})
}

// RunningBalanceIn applies the In predicate on the "runningBalance" field.
func RunningBalanceIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRunningBalance), v...))
	})
}

// RunningBalanceNotIn applies the NotIn predicate on the "runningBalance" field.
func RunningBalanceNotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRunningBalance), v...))
	})
}

// RunningBalanceGT applies the GT predicate on the "runningBalance" field.
func RunningBalanceGT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRunningBalance), v))
	})
}

// RunningBalanceGTE applies the GTE predicate on the "runningBalance" field.
func RunningBalanceGTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRunningBalance), v))
	})
}

// RunningBalanceLT applies the LT predicate on the "runningBalance" field.
func RunningBalanceLT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRunningBalance), v))
	})
}

// RunningBalanceLTE applies the LTE predicate on the "runningBalance" field.
func RunningBalanceLTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRunningBalance), v))
	})
}

// CreatedDateEQ applies the EQ predicate on the "createdDate" field.
func CreatedDateEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateNEQ applies the NEQ predicate on the "createdDate" field.
func CreatedDateNEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateIn applies the In predicate on the "createdDate" field.
func CreatedDateIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedDate), v...))
	})
}

// CreatedDateNotIn applies the NotIn predicate on the "createdDate" field.
func CreatedDateNotIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedDate), v...))
	})
}

// CreatedDateGT applies the GT predicate on the "createdDate" field.
func CreatedDateGT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateGTE applies the GTE predicate on the "createdDate" field.
func CreatedDateGTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateLT applies the LT predicate on the "createdDate" field.
func CreatedDateLT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateLTE applies the LTE predicate on the "createdDate" field.
func CreatedDateLTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedDate), v))
	})
}

// PostedDateEQ applies the EQ predicate on the "postedDate" field.
func PostedDateEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPostedDate), v))
	})
}

// PostedDateNEQ applies the NEQ predicate on the "postedDate" field.
func PostedDateNEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPostedDate), v))
	})
}

// PostedDateIn applies the In predicate on the "postedDate" field.
func PostedDateIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPostedDate), v...))
	})
}

// PostedDateNotIn applies the NotIn predicate on the "postedDate" field.
func PostedDateNotIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPostedDate), v...))
	})
}

// PostedDateGT applies the GT predicate on the "postedDate" field.
func PostedDateGT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPostedDate), v))
	})
}

// PostedDateGTE applies the GTE predicate on the "postedDate" field.
func PostedDateGTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPostedDate), v))
	})
}

// PostedDateLT applies the LT predicate on the "postedDate" field.
func PostedDateLT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPostedDate), v))
	})
}

// PostedDateLTE applies the LTE predicate on the "postedDate" field.
func PostedDateLTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPostedDate), v))
	})
}

// ExecutedDateEQ applies the EQ predicate on the "executedDate" field.
func ExecutedDateEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExecutedDate), v))
	})
}

// ExecutedDateNEQ applies the NEQ predicate on the "executedDate" field.
func ExecutedDateNEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExecutedDate), v))
	})
}

// ExecutedDateIn applies the In predicate on the "executedDate" field.
func ExecutedDateIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExecutedDate), v...))
	})
}

// ExecutedDateNotIn applies the NotIn predicate on the "executedDate" field.
func ExecutedDateNotIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExecutedDate), v...))
	})
}

// ExecutedDateGT applies the GT predicate on the "executedDate" field.
func ExecutedDateGT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExecutedDate), v))
	})
}

// ExecutedDateGTE applies the GTE predicate on the "executedDate" field.
func ExecutedDateGTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExecutedDate), v))
	})
}

// ExecutedDateLT applies the LT predicate on the "executedDate" field.
func ExecutedDateLT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExecutedDate), v))
	})
}

// ExecutedDateLTE applies the LTE predicate on the "executedDate" field.
func ExecutedDateLTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExecutedDate), v))
	})
}

// UpdatedDateEQ applies the EQ predicate on the "updatedDate" field.
func UpdatedDateEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedDate), v))
	})
}

// UpdatedDateNEQ applies the NEQ predicate on the "updatedDate" field.
func UpdatedDateNEQ(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedDate), v))
	})
}

// UpdatedDateIn applies the In predicate on the "updatedDate" field.
func UpdatedDateIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedDate), v...))
	})
}

// UpdatedDateNotIn applies the NotIn predicate on the "updatedDate" field.
func UpdatedDateNotIn(vs ...time.Time) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedDate), v...))
	})
}

// UpdatedDateGT applies the GT predicate on the "updatedDate" field.
func UpdatedDateGT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedDate), v))
	})
}

// UpdatedDateGTE applies the GTE predicate on the "updatedDate" field.
func UpdatedDateGTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedDate), v))
	})
}

// UpdatedDateLT applies the LT predicate on the "updatedDate" field.
func UpdatedDateLT(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedDate), v))
	})
}

// UpdatedDateLTE applies the LTE predicate on the "updatedDate" field.
func UpdatedDateLTE(v time.Time) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedDate), v))
	})
}

// DescriptionEQ applies the EQ predicate on the "description" field.
func DescriptionEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescription), v))
	})
}

// DescriptionNEQ applies the NEQ predicate on the "description" field.
func DescriptionNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDescription), v))
	})
}

// DescriptionIn applies the In predicate on the "description" field.
func DescriptionIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDescription), v...))
	})
}

// DescriptionNotIn applies the NotIn predicate on the "description" field.
func DescriptionNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDescription), v...))
	})
}

// DescriptionGT applies the GT predicate on the "description" field.
func DescriptionGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDescription), v))
	})
}

// DescriptionGTE applies the GTE predicate on the "description" field.
func DescriptionGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDescription), v))
	})
}

// DescriptionLT applies the LT predicate on the "description" field.
func DescriptionLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDescription), v))
	})
}

// DescriptionLTE applies the LTE predicate on the "description" field.
func DescriptionLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDescription), v))
	})
}

// DescriptionContains applies the Contains predicate on the "description" field.
func DescriptionContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDescription), v))
	})
}

// DescriptionHasPrefix applies the HasPrefix predicate on the "description" field.
func DescriptionHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDescription), v))
	})
}

// DescriptionHasSuffix applies the HasSuffix predicate on the "description" field.
func DescriptionHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDescription), v))
	})
}

// DescriptionIsNil applies the IsNil predicate on the "description" field.
func DescriptionIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDescription)))
	})
}

// DescriptionNotNil applies the NotNil predicate on the "description" field.
func DescriptionNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDescription)))
	})
}

// DescriptionEqualFold applies the EqualFold predicate on the "description" field.
func DescriptionEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDescription), v))
	})
}

// DescriptionContainsFold applies the ContainsFold predicate on the "description" field.
func DescriptionContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDescription), v))
	})
}

// MemoEQ applies the EQ predicate on the "memo" field.
func MemoEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMemo), v))
	})
}

// MemoNEQ applies the NEQ predicate on the "memo" field.
func MemoNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMemo), v))
	})
}

// MemoIn applies the In predicate on the "memo" field.
func MemoIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMemo), v...))
	})
}

// MemoNotIn applies the NotIn predicate on the "memo" field.
func MemoNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMemo), v...))
	})
}

// MemoGT applies the GT predicate on the "memo" field.
func MemoGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMemo), v))
	})
}

// MemoGTE applies the GTE predicate on the "memo" field.
func MemoGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMemo), v))
	})
}

// MemoLT applies the LT predicate on the "memo" field.
func MemoLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMemo), v))
	})
}

// MemoLTE applies the LTE predicate on the "memo" field.
func MemoLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMemo), v))
	})
}

// MemoContains applies the Contains predicate on the "memo" field.
func MemoContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMemo), v))
	})
}

// MemoHasPrefix applies the HasPrefix predicate on the "memo" field.
func MemoHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMemo), v))
	})
}

// MemoHasSuffix applies the HasSuffix predicate on the "memo" field.
func MemoHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMemo), v))
	})
}

// MemoIsNil applies the IsNil predicate on the "memo" field.
func MemoIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMemo)))
	})
}

// MemoNotNil applies the NotNil predicate on the "memo" field.
func MemoNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMemo)))
	})
}

// MemoEqualFold applies the EqualFold predicate on the "memo" field.
func MemoEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMemo), v))
	})
}

// MemoContainsFold applies the ContainsFold predicate on the "memo" field.
func MemoContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMemo), v))
	})
}

// GroupEQ applies the EQ predicate on the "group" field.
func GroupEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGroup), v))
	})
}

// GroupNEQ applies the NEQ predicate on the "group" field.
func GroupNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGroup), v))
	})
}

// GroupIn applies the In predicate on the "group" field.
func GroupIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGroup), v...))
	})
}

// GroupNotIn applies the NotIn predicate on the "group" field.
func GroupNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGroup), v...))
	})
}

// GroupGT applies the GT predicate on the "group" field.
func GroupGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGroup), v))
	})
}

// GroupGTE applies the GTE predicate on the "group" field.
func GroupGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGroup), v))
	})
}

// GroupLT applies the LT predicate on the "group" field.
func GroupLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGroup), v))
	})
}

// GroupLTE applies the LTE predicate on the "group" field.
func GroupLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGroup), v))
	})
}

// GroupContains applies the Contains predicate on the "group" field.
func GroupContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGroup), v))
	})
}

// GroupHasPrefix applies the HasPrefix predicate on the "group" field.
func GroupHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGroup), v))
	})
}

// GroupHasSuffix applies the HasSuffix predicate on the "group" field.
func GroupHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGroup), v))
	})
}

// GroupIsNil applies the IsNil predicate on the "group" field.
func GroupIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldGroup)))
	})
}

// GroupNotNil applies the NotNil predicate on the "group" field.
func GroupNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldGroup)))
	})
}

// GroupEqualFold applies the EqualFold predicate on the "group" field.
func GroupEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGroup), v))
	})
}

// GroupContainsFold applies the ContainsFold predicate on the "group" field.
func GroupContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGroup), v))
	})
}

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType), v))
	})
}

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType), v...))
	})
}

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType), v...))
	})
}

// TypeGT applies the GT predicate on the "type" field.
func TypeGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldType), v))
	})
}

// TypeGTE applies the GTE predicate on the "type" field.
func TypeGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldType), v))
	})
}

// TypeLT applies the LT predicate on the "type" field.
func TypeLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldType), v))
	})
}

// TypeLTE applies the LTE predicate on the "type" field.
func TypeLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldType), v))
	})
}

// TypeContains applies the Contains predicate on the "type" field.
func TypeContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldType), v))
	})
}

// TypeHasPrefix applies the HasPrefix predicate on the "type" field.
func TypeHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldType), v))
	})
}

// TypeHasSuffix applies the HasSuffix predicate on the "type" field.
func TypeHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldType), v))
	})
}

// TypeIsNil applies the IsNil predicate on the "type" field.
func TypeIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldType)))
	})
}

// TypeNotNil applies the NotNil predicate on the "type" field.
func TypeNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldType)))
	})
}

// TypeEqualFold applies the EqualFold predicate on the "type" field.
func TypeEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldType), v))
	})
}

// TypeContainsFold applies the ContainsFold predicate on the "type" field.
func TypeContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldType), v))
	})
}

// MainCategoryEQ applies the EQ predicate on the "mainCategory" field.
func MainCategoryEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMainCategory), v))
	})
}

// MainCategoryNEQ applies the NEQ predicate on the "mainCategory" field.
func MainCategoryNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMainCategory), v))
	})
}

// MainCategoryIn applies the In predicate on the "mainCategory" field.
func MainCategoryIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMainCategory), v...))
	})
}

// MainCategoryNotIn applies the NotIn predicate on the "mainCategory" field.
func MainCategoryNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMainCategory), v...))
	})
}

// MainCategoryGT applies the GT predicate on the "mainCategory" field.
func MainCategoryGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMainCategory), v))
	})
}

// MainCategoryGTE applies the GTE predicate on the "mainCategory" field.
func MainCategoryGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMainCategory), v))
	})
}

// MainCategoryLT applies the LT predicate on the "mainCategory" field.
func MainCategoryLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMainCategory), v))
	})
}

// MainCategoryLTE applies the LTE predicate on the "mainCategory" field.
func MainCategoryLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMainCategory), v))
	})
}

// MainCategoryContains applies the Contains predicate on the "mainCategory" field.
func MainCategoryContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMainCategory), v))
	})
}

// MainCategoryHasPrefix applies the HasPrefix predicate on the "mainCategory" field.
func MainCategoryHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMainCategory), v))
	})
}

// MainCategoryHasSuffix applies the HasSuffix predicate on the "mainCategory" field.
func MainCategoryHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMainCategory), v))
	})
}

// MainCategoryIsNil applies the IsNil predicate on the "mainCategory" field.
func MainCategoryIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMainCategory)))
	})
}

// MainCategoryNotNil applies the NotNil predicate on the "mainCategory" field.
func MainCategoryNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMainCategory)))
	})
}

// MainCategoryEqualFold applies the EqualFold predicate on the "mainCategory" field.
func MainCategoryEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMainCategory), v))
	})
}

// MainCategoryContainsFold applies the ContainsFold predicate on the "mainCategory" field.
func MainCategoryContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMainCategory), v))
	})
}

// SubCategoryEQ applies the EQ predicate on the "subCategory" field.
func SubCategoryEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSubCategory), v))
	})
}

// SubCategoryNEQ applies the NEQ predicate on the "subCategory" field.
func SubCategoryNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSubCategory), v))
	})
}

// SubCategoryIn applies the In predicate on the "subCategory" field.
func SubCategoryIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSubCategory), v...))
	})
}

// SubCategoryNotIn applies the NotIn predicate on the "subCategory" field.
func SubCategoryNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSubCategory), v...))
	})
}

// SubCategoryGT applies the GT predicate on the "subCategory" field.
func SubCategoryGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSubCategory), v))
	})
}

// SubCategoryGTE applies the GTE predicate on the "subCategory" field.
func SubCategoryGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSubCategory), v))
	})
}

// SubCategoryLT applies the LT predicate on the "subCategory" field.
func SubCategoryLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSubCategory), v))
	})
}

// SubCategoryLTE applies the LTE predicate on the "subCategory" field.
func SubCategoryLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSubCategory), v))
	})
}

// SubCategoryContains applies the Contains predicate on the "subCategory" field.
func SubCategoryContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSubCategory), v))
	})
}

// SubCategoryHasPrefix applies the HasPrefix predicate on the "subCategory" field.
func SubCategoryHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSubCategory), v))
	})
}

// SubCategoryHasSuffix applies the HasSuffix predicate on the "subCategory" field.
func SubCategoryHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSubCategory), v))
	})
}

// SubCategoryIsNil applies the IsNil predicate on the "subCategory" field.
func SubCategoryIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSubCategory)))
	})
}

// SubCategoryNotNil applies the NotNil predicate on the "subCategory" field.
func SubCategoryNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSubCategory)))
	})
}

// SubCategoryEqualFold applies the EqualFold predicate on the "subCategory" field.
func SubCategoryEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSubCategory), v))
	})
}

// SubCategoryContainsFold applies the ContainsFold predicate on the "subCategory" field.
func SubCategoryContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSubCategory), v))
	})
}

// CheckNumberEQ applies the EQ predicate on the "checkNumber" field.
func CheckNumberEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberNEQ applies the NEQ predicate on the "checkNumber" field.
func CheckNumberNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberIn applies the In predicate on the "checkNumber" field.
func CheckNumberIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCheckNumber), v...))
	})
}

// CheckNumberNotIn applies the NotIn predicate on the "checkNumber" field.
func CheckNumberNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCheckNumber), v...))
	})
}

// CheckNumberGT applies the GT predicate on the "checkNumber" field.
func CheckNumberGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberGTE applies the GTE predicate on the "checkNumber" field.
func CheckNumberGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberLT applies the LT predicate on the "checkNumber" field.
func CheckNumberLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberLTE applies the LTE predicate on the "checkNumber" field.
func CheckNumberLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberContains applies the Contains predicate on the "checkNumber" field.
func CheckNumberContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberHasPrefix applies the HasPrefix predicate on the "checkNumber" field.
func CheckNumberHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberHasSuffix applies the HasSuffix predicate on the "checkNumber" field.
func CheckNumberHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberIsNil applies the IsNil predicate on the "checkNumber" field.
func CheckNumberIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCheckNumber)))
	})
}

// CheckNumberNotNil applies the NotNil predicate on the "checkNumber" field.
func CheckNumberNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCheckNumber)))
	})
}

// CheckNumberEqualFold applies the EqualFold predicate on the "checkNumber" field.
func CheckNumberEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCheckNumber), v))
	})
}

// CheckNumberContainsFold applies the ContainsFold predicate on the "checkNumber" field.
func CheckNumberContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCheckNumber), v))
	})
}

// LatitudeEQ applies the EQ predicate on the "latitude" field.
func LatitudeEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLatitude), v))
	})
}

// LatitudeNEQ applies the NEQ predicate on the "latitude" field.
func LatitudeNEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLatitude), v))
	})
}

// LatitudeIn applies the In predicate on the "latitude" field.
func LatitudeIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLatitude), v...))
	})
}

// LatitudeNotIn applies the NotIn predicate on the "latitude" field.
func LatitudeNotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLatitude), v...))
	})
}

// LatitudeGT applies the GT predicate on the "latitude" field.
func LatitudeGT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLatitude), v))
	})
}

// LatitudeGTE applies the GTE predicate on the "latitude" field.
func LatitudeGTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLatitude), v))
	})
}

// LatitudeLT applies the LT predicate on the "latitude" field.
func LatitudeLT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLatitude), v))
	})
}

// LatitudeLTE applies the LTE predicate on the "latitude" field.
func LatitudeLTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLatitude), v))
	})
}

// LatitudeIsNil applies the IsNil predicate on the "latitude" field.
func LatitudeIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLatitude)))
	})
}

// LatitudeNotNil applies the NotNil predicate on the "latitude" field.
func LatitudeNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLatitude)))
	})
}

// LongitudeEQ applies the EQ predicate on the "longitude" field.
func LongitudeEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLongitude), v))
	})
}

// LongitudeNEQ applies the NEQ predicate on the "longitude" field.
func LongitudeNEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLongitude), v))
	})
}

// LongitudeIn applies the In predicate on the "longitude" field.
func LongitudeIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLongitude), v...))
	})
}

// LongitudeNotIn applies the NotIn predicate on the "longitude" field.
func LongitudeNotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLongitude), v...))
	})
}

// LongitudeGT applies the GT predicate on the "longitude" field.
func LongitudeGT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLongitude), v))
	})
}

// LongitudeGTE applies the GTE predicate on the "longitude" field.
func LongitudeGTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLongitude), v))
	})
}

// LongitudeLT applies the LT predicate on the "longitude" field.
func LongitudeLT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLongitude), v))
	})
}

// LongitudeLTE applies the LTE predicate on the "longitude" field.
func LongitudeLTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLongitude), v))
	})
}

// LongitudeIsNil applies the IsNil predicate on the "longitude" field.
func LongitudeIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLongitude)))
	})
}

// LongitudeNotNil applies the NotNil predicate on the "longitude" field.
func LongitudeNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLongitude)))
	})
}

// MerchantCodeEQ applies the EQ predicate on the "merchantCode" field.
func MerchantCodeEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeNEQ applies the NEQ predicate on the "merchantCode" field.
func MerchantCodeNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeIn applies the In predicate on the "merchantCode" field.
func MerchantCodeIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMerchantCode), v...))
	})
}

// MerchantCodeNotIn applies the NotIn predicate on the "merchantCode" field.
func MerchantCodeNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMerchantCode), v...))
	})
}

// MerchantCodeGT applies the GT predicate on the "merchantCode" field.
func MerchantCodeGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeGTE applies the GTE predicate on the "merchantCode" field.
func MerchantCodeGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeLT applies the LT predicate on the "merchantCode" field.
func MerchantCodeLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeLTE applies the LTE predicate on the "merchantCode" field.
func MerchantCodeLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeContains applies the Contains predicate on the "merchantCode" field.
func MerchantCodeContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeHasPrefix applies the HasPrefix predicate on the "merchantCode" field.
func MerchantCodeHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeHasSuffix applies the HasSuffix predicate on the "merchantCode" field.
func MerchantCodeHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeIsNil applies the IsNil predicate on the "merchantCode" field.
func MerchantCodeIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMerchantCode)))
	})
}

// MerchantCodeNotNil applies the NotNil predicate on the "merchantCode" field.
func MerchantCodeNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMerchantCode)))
	})
}

// MerchantCodeEqualFold applies the EqualFold predicate on the "merchantCode" field.
func MerchantCodeEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMerchantCode), v))
	})
}

// MerchantCodeContainsFold applies the ContainsFold predicate on the "merchantCode" field.
func MerchantCodeContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMerchantCode), v))
	})
}

// ReversalEQ applies the EQ predicate on the "reversal" field.
func ReversalEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversal), v))
	})
}

// ReversalNEQ applies the NEQ predicate on the "reversal" field.
func ReversalNEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReversal), v))
	})
}

// ReversalForEQ applies the EQ predicate on the "reversalFor" field.
func ReversalForEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversalFor), v))
	})
}

// ReversalForNEQ applies the NEQ predicate on the "reversalFor" field.
func ReversalForNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReversalFor), v))
	})
}

// ReversalForIn applies the In predicate on the "reversalFor" field.
func ReversalForIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReversalFor), v...))
	})
}

// ReversalForNotIn applies the NotIn predicate on the "reversalFor" field.
func ReversalForNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReversalFor), v...))
	})
}

// ReversalForGT applies the GT predicate on the "reversalFor" field.
func ReversalForGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReversalFor), v))
	})
}

// ReversalForGTE applies the GTE predicate on the "reversalFor" field.
func ReversalForGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReversalFor), v))
	})
}

// ReversalForLT applies the LT predicate on the "reversalFor" field.
func ReversalForLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReversalFor), v))
	})
}

// ReversalForLTE applies the LTE predicate on the "reversalFor" field.
func ReversalForLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReversalFor), v))
	})
}

// ReversalForContains applies the Contains predicate on the "reversalFor" field.
func ReversalForContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldReversalFor), v))
	})
}

// ReversalForHasPrefix applies the HasPrefix predicate on the "reversalFor" field.
func ReversalForHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldReversalFor), v))
	})
}

// ReversalForHasSuffix applies the HasSuffix predicate on the "reversalFor" field.
func ReversalForHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldReversalFor), v))
	})
}

// ReversalForIsNil applies the IsNil predicate on the "reversalFor" field.
func ReversalForIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldReversalFor)))
	})
}

// ReversalForNotNil applies the NotNil predicate on the "reversalFor" field.
func ReversalForNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldReversalFor)))
	})
}

// ReversalForEqualFold applies the EqualFold predicate on the "reversalFor" field.
func ReversalForEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldReversalFor), v))
	})
}

// ReversalForContainsFold applies the ContainsFold predicate on the "reversalFor" field.
func ReversalForContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldReversalFor), v))
	})
}

// ReversedEQ applies the EQ predicate on the "reversed" field.
func ReversedEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversed), v))
	})
}

// ReversedNEQ applies the NEQ predicate on the "reversed" field.
func ReversedNEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReversed), v))
	})
}

// ReversedByEQ applies the EQ predicate on the "reversedBy" field.
func ReversedByEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReversedBy), v))
	})
}

// ReversedByNEQ applies the NEQ predicate on the "reversedBy" field.
func ReversedByNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReversedBy), v))
	})
}

// ReversedByIn applies the In predicate on the "reversedBy" field.
func ReversedByIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReversedBy), v...))
	})
}

// ReversedByNotIn applies the NotIn predicate on the "reversedBy" field.
func ReversedByNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReversedBy), v...))
	})
}

// ReversedByGT applies the GT predicate on the "reversedBy" field.
func ReversedByGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReversedBy), v))
	})
}

// ReversedByGTE applies the GTE predicate on the "reversedBy" field.
func ReversedByGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReversedBy), v))
	})
}

// ReversedByLT applies the LT predicate on the "reversedBy" field.
func ReversedByLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReversedBy), v))
	})
}

// ReversedByLTE applies the LTE predicate on the "reversedBy" field.
func ReversedByLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReversedBy), v))
	})
}

// ReversedByContains applies the Contains predicate on the "reversedBy" field.
func ReversedByContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldReversedBy), v))
	})
}

// ReversedByHasPrefix applies the HasPrefix predicate on the "reversedBy" field.
func ReversedByHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldReversedBy), v))
	})
}

// ReversedByHasSuffix applies the HasSuffix predicate on the "reversedBy" field.
func ReversedByHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldReversedBy), v))
	})
}

// ReversedByIsNil applies the IsNil predicate on the "reversedBy" field.
func ReversedByIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldReversedBy)))
	})
}

// ReversedByNotNil applies the NotNil predicate on the "reversedBy" field.
func ReversedByNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldReversedBy)))
	})
}

// ReversedByEqualFold applies the EqualFold predicate on the "reversedBy" field.
func ReversedByEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldReversedBy), v))
	})
}

// ReversedByContainsFold applies the ContainsFold predicate on the "reversedBy" field.
func ReversedByContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldReversedBy), v))
	})
}

// URLEQ applies the EQ predicate on the "url" field.
func URLEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldURL), v))
	})
}

// URLNEQ applies the NEQ predicate on the "url" field.
func URLNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldURL), v))
	})
}

// URLIn applies the In predicate on the "url" field.
func URLIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldURL), v...))
	})
}

// URLNotIn applies the NotIn predicate on the "url" field.
func URLNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldURL), v...))
	})
}

// URLGT applies the GT predicate on the "url" field.
func URLGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldURL), v))
	})
}

// URLGTE applies the GTE predicate on the "url" field.
func URLGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldURL), v))
	})
}

// URLLT applies the LT predicate on the "url" field.
func URLLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldURL), v))
	})
}

// URLLTE applies the LTE predicate on the "url" field.
func URLLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldURL), v))
	})
}

// URLContains applies the Contains predicate on the "url" field.
func URLContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldURL), v))
	})
}

// URLHasPrefix applies the HasPrefix predicate on the "url" field.
func URLHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldURL), v))
	})
}

// URLHasSuffix applies the HasSuffix predicate on the "url" field.
func URLHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldURL), v))
	})
}

// URLIsNil applies the IsNil predicate on the "url" field.
func URLIsNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldURL)))
	})
}

// URLNotNil applies the NotNil predicate on the "url" field.
func URLNotNil() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldURL)))
	})
}

// URLEqualFold applies the EqualFold predicate on the "url" field.
func URLEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldURL), v))
	})
}

// URLContainsFold applies the ContainsFold predicate on the "url" field.
func URLContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldURL), v))
	})
}

// HasImages applies the HasEdge predicate on the "images" edge.
func HasImages() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ImagesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ImagesTable, ImagesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasImagesWith applies the HasEdge predicate on the "images" edge with a given conditions (other predicates).
func HasImagesWith(preds ...predicate.BinaryItem) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ImagesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ImagesTable, ImagesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Transaction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Transaction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Transaction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		p(s.Not())
	})
}
