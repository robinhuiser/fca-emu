// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/robinhuiser/fca-emu/ent/binaryitem"
	"github.com/robinhuiser/fca-emu/ent/predicate"
	"github.com/robinhuiser/fca-emu/ent/transaction"
)

// TransactionUpdate is the builder for updating Transaction entities.
type TransactionUpdate struct {
	config
	hooks    []Hook
	mutation *TransactionMutation
}

// Where adds a new predicate for the TransactionUpdate builder.
func (tu *TransactionUpdate) Where(ps ...predicate.Transaction) *TransactionUpdate {
	tu.mutation.predicates = append(tu.mutation.predicates, ps...)
	return tu
}

// SetSequenceInDay sets the "sequenceInDay" field.
func (tu *TransactionUpdate) SetSequenceInDay(i int) *TransactionUpdate {
	tu.mutation.ResetSequenceInDay()
	tu.mutation.SetSequenceInDay(i)
	return tu
}

// SetNillableSequenceInDay sets the "sequenceInDay" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableSequenceInDay(i *int) *TransactionUpdate {
	if i != nil {
		tu.SetSequenceInDay(*i)
	}
	return tu
}

// AddSequenceInDay adds i to the "sequenceInDay" field.
func (tu *TransactionUpdate) AddSequenceInDay(i int) *TransactionUpdate {
	tu.mutation.AddSequenceInDay(i)
	return tu
}

// ClearSequenceInDay clears the value of the "sequenceInDay" field.
func (tu *TransactionUpdate) ClearSequenceInDay() *TransactionUpdate {
	tu.mutation.ClearSequenceInDay()
	return tu
}

// SetStatus sets the "status" field.
func (tu *TransactionUpdate) SetStatus(t transaction.Status) *TransactionUpdate {
	tu.mutation.SetStatus(t)
	return tu
}

// SetExecutedAmount sets the "executedAmount" field.
func (tu *TransactionUpdate) SetExecutedAmount(f float64) *TransactionUpdate {
	tu.mutation.ResetExecutedAmount()
	tu.mutation.SetExecutedAmount(f)
	return tu
}

// AddExecutedAmount adds f to the "executedAmount" field.
func (tu *TransactionUpdate) AddExecutedAmount(f float64) *TransactionUpdate {
	tu.mutation.AddExecutedAmount(f)
	return tu
}

// SetExecutedCurrencyCode sets the "executedCurrencyCode" field.
func (tu *TransactionUpdate) SetExecutedCurrencyCode(s string) *TransactionUpdate {
	tu.mutation.SetExecutedCurrencyCode(s)
	return tu
}

// SetExchangeRate sets the "exchangeRate" field.
func (tu *TransactionUpdate) SetExchangeRate(f float64) *TransactionUpdate {
	tu.mutation.ResetExchangeRate()
	tu.mutation.SetExchangeRate(f)
	return tu
}

// SetNillableExchangeRate sets the "exchangeRate" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableExchangeRate(f *float64) *TransactionUpdate {
	if f != nil {
		tu.SetExchangeRate(*f)
	}
	return tu
}

// AddExchangeRate adds f to the "exchangeRate" field.
func (tu *TransactionUpdate) AddExchangeRate(f float64) *TransactionUpdate {
	tu.mutation.AddExchangeRate(f)
	return tu
}

// ClearExchangeRate clears the value of the "exchangeRate" field.
func (tu *TransactionUpdate) ClearExchangeRate() *TransactionUpdate {
	tu.mutation.ClearExchangeRate()
	return tu
}

// SetOriginatingAmount sets the "originatingAmount" field.
func (tu *TransactionUpdate) SetOriginatingAmount(f float64) *TransactionUpdate {
	tu.mutation.ResetOriginatingAmount()
	tu.mutation.SetOriginatingAmount(f)
	return tu
}

// SetNillableOriginatingAmount sets the "originatingAmount" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableOriginatingAmount(f *float64) *TransactionUpdate {
	if f != nil {
		tu.SetOriginatingAmount(*f)
	}
	return tu
}

// AddOriginatingAmount adds f to the "originatingAmount" field.
func (tu *TransactionUpdate) AddOriginatingAmount(f float64) *TransactionUpdate {
	tu.mutation.AddOriginatingAmount(f)
	return tu
}

// ClearOriginatingAmount clears the value of the "originatingAmount" field.
func (tu *TransactionUpdate) ClearOriginatingAmount() *TransactionUpdate {
	tu.mutation.ClearOriginatingAmount()
	return tu
}

// SetOriginatingCurrencyCode sets the "originatingCurrencyCode" field.
func (tu *TransactionUpdate) SetOriginatingCurrencyCode(s string) *TransactionUpdate {
	tu.mutation.SetOriginatingCurrencyCode(s)
	return tu
}

// SetNillableOriginatingCurrencyCode sets the "originatingCurrencyCode" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableOriginatingCurrencyCode(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetOriginatingCurrencyCode(*s)
	}
	return tu
}

// ClearOriginatingCurrencyCode clears the value of the "originatingCurrencyCode" field.
func (tu *TransactionUpdate) ClearOriginatingCurrencyCode() *TransactionUpdate {
	tu.mutation.ClearOriginatingCurrencyCode()
	return tu
}

// SetDirection sets the "direction" field.
func (tu *TransactionUpdate) SetDirection(t transaction.Direction) *TransactionUpdate {
	tu.mutation.SetDirection(t)
	return tu
}

// SetRunningBalance sets the "runningBalance" field.
func (tu *TransactionUpdate) SetRunningBalance(f float64) *TransactionUpdate {
	tu.mutation.ResetRunningBalance()
	tu.mutation.SetRunningBalance(f)
	return tu
}

// AddRunningBalance adds f to the "runningBalance" field.
func (tu *TransactionUpdate) AddRunningBalance(f float64) *TransactionUpdate {
	tu.mutation.AddRunningBalance(f)
	return tu
}

// SetCreatedDate sets the "createdDate" field.
func (tu *TransactionUpdate) SetCreatedDate(t time.Time) *TransactionUpdate {
	tu.mutation.SetCreatedDate(t)
	return tu
}

// SetPostedDate sets the "postedDate" field.
func (tu *TransactionUpdate) SetPostedDate(t time.Time) *TransactionUpdate {
	tu.mutation.SetPostedDate(t)
	return tu
}

// SetNillablePostedDate sets the "postedDate" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillablePostedDate(t *time.Time) *TransactionUpdate {
	if t != nil {
		tu.SetPostedDate(*t)
	}
	return tu
}

// ClearPostedDate clears the value of the "postedDate" field.
func (tu *TransactionUpdate) ClearPostedDate() *TransactionUpdate {
	tu.mutation.ClearPostedDate()
	return tu
}

// SetExecutedDate sets the "executedDate" field.
func (tu *TransactionUpdate) SetExecutedDate(t time.Time) *TransactionUpdate {
	tu.mutation.SetExecutedDate(t)
	return tu
}

// SetNillableExecutedDate sets the "executedDate" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableExecutedDate(t *time.Time) *TransactionUpdate {
	if t != nil {
		tu.SetExecutedDate(*t)
	}
	return tu
}

// ClearExecutedDate clears the value of the "executedDate" field.
func (tu *TransactionUpdate) ClearExecutedDate() *TransactionUpdate {
	tu.mutation.ClearExecutedDate()
	return tu
}

// SetUpdatedDate sets the "updatedDate" field.
func (tu *TransactionUpdate) SetUpdatedDate(t time.Time) *TransactionUpdate {
	tu.mutation.SetUpdatedDate(t)
	return tu
}

// SetNillableUpdatedDate sets the "updatedDate" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableUpdatedDate(t *time.Time) *TransactionUpdate {
	if t != nil {
		tu.SetUpdatedDate(*t)
	}
	return tu
}

// ClearUpdatedDate clears the value of the "updatedDate" field.
func (tu *TransactionUpdate) ClearUpdatedDate() *TransactionUpdate {
	tu.mutation.ClearUpdatedDate()
	return tu
}

// SetDescription sets the "description" field.
func (tu *TransactionUpdate) SetDescription(s string) *TransactionUpdate {
	tu.mutation.SetDescription(s)
	return tu
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableDescription(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetDescription(*s)
	}
	return tu
}

// ClearDescription clears the value of the "description" field.
func (tu *TransactionUpdate) ClearDescription() *TransactionUpdate {
	tu.mutation.ClearDescription()
	return tu
}

// SetMemo sets the "memo" field.
func (tu *TransactionUpdate) SetMemo(s string) *TransactionUpdate {
	tu.mutation.SetMemo(s)
	return tu
}

// SetNillableMemo sets the "memo" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableMemo(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetMemo(*s)
	}
	return tu
}

// ClearMemo clears the value of the "memo" field.
func (tu *TransactionUpdate) ClearMemo() *TransactionUpdate {
	tu.mutation.ClearMemo()
	return tu
}

// SetGroup sets the "group" field.
func (tu *TransactionUpdate) SetGroup(s string) *TransactionUpdate {
	tu.mutation.SetGroup(s)
	return tu
}

// SetNillableGroup sets the "group" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableGroup(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetGroup(*s)
	}
	return tu
}

// ClearGroup clears the value of the "group" field.
func (tu *TransactionUpdate) ClearGroup() *TransactionUpdate {
	tu.mutation.ClearGroup()
	return tu
}

// SetType sets the "type" field.
func (tu *TransactionUpdate) SetType(s string) *TransactionUpdate {
	tu.mutation.SetType(s)
	return tu
}

// SetNillableType sets the "type" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableType(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetType(*s)
	}
	return tu
}

// ClearType clears the value of the "type" field.
func (tu *TransactionUpdate) ClearType() *TransactionUpdate {
	tu.mutation.ClearType()
	return tu
}

// SetMainCategory sets the "mainCategory" field.
func (tu *TransactionUpdate) SetMainCategory(s string) *TransactionUpdate {
	tu.mutation.SetMainCategory(s)
	return tu
}

// SetNillableMainCategory sets the "mainCategory" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableMainCategory(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetMainCategory(*s)
	}
	return tu
}

// ClearMainCategory clears the value of the "mainCategory" field.
func (tu *TransactionUpdate) ClearMainCategory() *TransactionUpdate {
	tu.mutation.ClearMainCategory()
	return tu
}

// SetSubCategory sets the "subCategory" field.
func (tu *TransactionUpdate) SetSubCategory(s string) *TransactionUpdate {
	tu.mutation.SetSubCategory(s)
	return tu
}

// SetNillableSubCategory sets the "subCategory" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableSubCategory(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetSubCategory(*s)
	}
	return tu
}

// ClearSubCategory clears the value of the "subCategory" field.
func (tu *TransactionUpdate) ClearSubCategory() *TransactionUpdate {
	tu.mutation.ClearSubCategory()
	return tu
}

// SetCheckNumber sets the "checkNumber" field.
func (tu *TransactionUpdate) SetCheckNumber(s string) *TransactionUpdate {
	tu.mutation.SetCheckNumber(s)
	return tu
}

// SetNillableCheckNumber sets the "checkNumber" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableCheckNumber(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetCheckNumber(*s)
	}
	return tu
}

// ClearCheckNumber clears the value of the "checkNumber" field.
func (tu *TransactionUpdate) ClearCheckNumber() *TransactionUpdate {
	tu.mutation.ClearCheckNumber()
	return tu
}

// SetLatitude sets the "latitude" field.
func (tu *TransactionUpdate) SetLatitude(f float64) *TransactionUpdate {
	tu.mutation.ResetLatitude()
	tu.mutation.SetLatitude(f)
	return tu
}

// SetNillableLatitude sets the "latitude" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableLatitude(f *float64) *TransactionUpdate {
	if f != nil {
		tu.SetLatitude(*f)
	}
	return tu
}

// AddLatitude adds f to the "latitude" field.
func (tu *TransactionUpdate) AddLatitude(f float64) *TransactionUpdate {
	tu.mutation.AddLatitude(f)
	return tu
}

// ClearLatitude clears the value of the "latitude" field.
func (tu *TransactionUpdate) ClearLatitude() *TransactionUpdate {
	tu.mutation.ClearLatitude()
	return tu
}

// SetLongitude sets the "longitude" field.
func (tu *TransactionUpdate) SetLongitude(f float64) *TransactionUpdate {
	tu.mutation.ResetLongitude()
	tu.mutation.SetLongitude(f)
	return tu
}

// SetNillableLongitude sets the "longitude" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableLongitude(f *float64) *TransactionUpdate {
	if f != nil {
		tu.SetLongitude(*f)
	}
	return tu
}

// AddLongitude adds f to the "longitude" field.
func (tu *TransactionUpdate) AddLongitude(f float64) *TransactionUpdate {
	tu.mutation.AddLongitude(f)
	return tu
}

// ClearLongitude clears the value of the "longitude" field.
func (tu *TransactionUpdate) ClearLongitude() *TransactionUpdate {
	tu.mutation.ClearLongitude()
	return tu
}

// SetMerchantCode sets the "merchantCode" field.
func (tu *TransactionUpdate) SetMerchantCode(s string) *TransactionUpdate {
	tu.mutation.SetMerchantCode(s)
	return tu
}

// SetNillableMerchantCode sets the "merchantCode" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableMerchantCode(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetMerchantCode(*s)
	}
	return tu
}

// ClearMerchantCode clears the value of the "merchantCode" field.
func (tu *TransactionUpdate) ClearMerchantCode() *TransactionUpdate {
	tu.mutation.ClearMerchantCode()
	return tu
}

// SetReversal sets the "reversal" field.
func (tu *TransactionUpdate) SetReversal(b bool) *TransactionUpdate {
	tu.mutation.SetReversal(b)
	return tu
}

// SetReversalFor sets the "reversalFor" field.
func (tu *TransactionUpdate) SetReversalFor(s string) *TransactionUpdate {
	tu.mutation.SetReversalFor(s)
	return tu
}

// SetNillableReversalFor sets the "reversalFor" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableReversalFor(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetReversalFor(*s)
	}
	return tu
}

// ClearReversalFor clears the value of the "reversalFor" field.
func (tu *TransactionUpdate) ClearReversalFor() *TransactionUpdate {
	tu.mutation.ClearReversalFor()
	return tu
}

// SetReversed sets the "reversed" field.
func (tu *TransactionUpdate) SetReversed(b bool) *TransactionUpdate {
	tu.mutation.SetReversed(b)
	return tu
}

// SetReversedBy sets the "reversedBy" field.
func (tu *TransactionUpdate) SetReversedBy(s string) *TransactionUpdate {
	tu.mutation.SetReversedBy(s)
	return tu
}

// SetNillableReversedBy sets the "reversedBy" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableReversedBy(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetReversedBy(*s)
	}
	return tu
}

// ClearReversedBy clears the value of the "reversedBy" field.
func (tu *TransactionUpdate) ClearReversedBy() *TransactionUpdate {
	tu.mutation.ClearReversedBy()
	return tu
}

// SetURL sets the "url" field.
func (tu *TransactionUpdate) SetURL(s string) *TransactionUpdate {
	tu.mutation.SetURL(s)
	return tu
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (tu *TransactionUpdate) SetNillableURL(s *string) *TransactionUpdate {
	if s != nil {
		tu.SetURL(*s)
	}
	return tu
}

// ClearURL clears the value of the "url" field.
func (tu *TransactionUpdate) ClearURL() *TransactionUpdate {
	tu.mutation.ClearURL()
	return tu
}

// AddImageIDs adds the "images" edge to the BinaryItem entity by IDs.
func (tu *TransactionUpdate) AddImageIDs(ids ...int) *TransactionUpdate {
	tu.mutation.AddImageIDs(ids...)
	return tu
}

// AddImages adds the "images" edges to the BinaryItem entity.
func (tu *TransactionUpdate) AddImages(b ...*BinaryItem) *TransactionUpdate {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return tu.AddImageIDs(ids...)
}

// Mutation returns the TransactionMutation object of the builder.
func (tu *TransactionUpdate) Mutation() *TransactionMutation {
	return tu.mutation
}

// ClearImages clears all "images" edges to the BinaryItem entity.
func (tu *TransactionUpdate) ClearImages() *TransactionUpdate {
	tu.mutation.ClearImages()
	return tu
}

// RemoveImageIDs removes the "images" edge to BinaryItem entities by IDs.
func (tu *TransactionUpdate) RemoveImageIDs(ids ...int) *TransactionUpdate {
	tu.mutation.RemoveImageIDs(ids...)
	return tu
}

// RemoveImages removes "images" edges to BinaryItem entities.
func (tu *TransactionUpdate) RemoveImages(b ...*BinaryItem) *TransactionUpdate {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return tu.RemoveImageIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (tu *TransactionUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(tu.hooks) == 0 {
		if err = tu.check(); err != nil {
			return 0, err
		}
		affected, err = tu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*TransactionMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = tu.check(); err != nil {
				return 0, err
			}
			tu.mutation = mutation
			affected, err = tu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(tu.hooks) - 1; i >= 0; i-- {
			mut = tu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, tu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (tu *TransactionUpdate) SaveX(ctx context.Context) int {
	affected, err := tu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (tu *TransactionUpdate) Exec(ctx context.Context) error {
	_, err := tu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tu *TransactionUpdate) ExecX(ctx context.Context) {
	if err := tu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tu *TransactionUpdate) check() error {
	if v, ok := tu.mutation.Status(); ok {
		if err := transaction.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf("ent: validator failed for field \"status\": %w", err)}
		}
	}
	if v, ok := tu.mutation.ExecutedCurrencyCode(); ok {
		if err := transaction.ExecutedCurrencyCodeValidator(v); err != nil {
			return &ValidationError{Name: "executedCurrencyCode", err: fmt.Errorf("ent: validator failed for field \"executedCurrencyCode\": %w", err)}
		}
	}
	if v, ok := tu.mutation.OriginatingCurrencyCode(); ok {
		if err := transaction.OriginatingCurrencyCodeValidator(v); err != nil {
			return &ValidationError{Name: "originatingCurrencyCode", err: fmt.Errorf("ent: validator failed for field \"originatingCurrencyCode\": %w", err)}
		}
	}
	if v, ok := tu.mutation.Direction(); ok {
		if err := transaction.DirectionValidator(v); err != nil {
			return &ValidationError{Name: "direction", err: fmt.Errorf("ent: validator failed for field \"direction\": %w", err)}
		}
	}
	return nil
}

func (tu *TransactionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   transaction.Table,
			Columns: transaction.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: transaction.FieldID,
			},
		},
	}
	if ps := tu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tu.mutation.SequenceInDay(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: transaction.FieldSequenceInDay,
		})
	}
	if value, ok := tu.mutation.AddedSequenceInDay(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: transaction.FieldSequenceInDay,
		})
	}
	if tu.mutation.SequenceInDayCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: transaction.FieldSequenceInDay,
		})
	}
	if value, ok := tu.mutation.Status(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: transaction.FieldStatus,
		})
	}
	if value, ok := tu.mutation.ExecutedAmount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExecutedAmount,
		})
	}
	if value, ok := tu.mutation.AddedExecutedAmount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExecutedAmount,
		})
	}
	if value, ok := tu.mutation.ExecutedCurrencyCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldExecutedCurrencyCode,
		})
	}
	if value, ok := tu.mutation.ExchangeRate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExchangeRate,
		})
	}
	if value, ok := tu.mutation.AddedExchangeRate(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExchangeRate,
		})
	}
	if tu.mutation.ExchangeRateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldExchangeRate,
		})
	}
	if value, ok := tu.mutation.OriginatingAmount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldOriginatingAmount,
		})
	}
	if value, ok := tu.mutation.AddedOriginatingAmount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldOriginatingAmount,
		})
	}
	if tu.mutation.OriginatingAmountCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldOriginatingAmount,
		})
	}
	if value, ok := tu.mutation.OriginatingCurrencyCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldOriginatingCurrencyCode,
		})
	}
	if tu.mutation.OriginatingCurrencyCodeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldOriginatingCurrencyCode,
		})
	}
	if value, ok := tu.mutation.Direction(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: transaction.FieldDirection,
		})
	}
	if value, ok := tu.mutation.RunningBalance(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldRunningBalance,
		})
	}
	if value, ok := tu.mutation.AddedRunningBalance(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldRunningBalance,
		})
	}
	if value, ok := tu.mutation.CreatedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldCreatedDate,
		})
	}
	if value, ok := tu.mutation.PostedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldPostedDate,
		})
	}
	if tu.mutation.PostedDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: transaction.FieldPostedDate,
		})
	}
	if value, ok := tu.mutation.ExecutedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldExecutedDate,
		})
	}
	if tu.mutation.ExecutedDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: transaction.FieldExecutedDate,
		})
	}
	if value, ok := tu.mutation.UpdatedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldUpdatedDate,
		})
	}
	if tu.mutation.UpdatedDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: transaction.FieldUpdatedDate,
		})
	}
	if value, ok := tu.mutation.Description(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldDescription,
		})
	}
	if tu.mutation.DescriptionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldDescription,
		})
	}
	if value, ok := tu.mutation.Memo(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldMemo,
		})
	}
	if tu.mutation.MemoCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldMemo,
		})
	}
	if value, ok := tu.mutation.Group(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldGroup,
		})
	}
	if tu.mutation.GroupCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldGroup,
		})
	}
	if value, ok := tu.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldType,
		})
	}
	if tu.mutation.TypeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldType,
		})
	}
	if value, ok := tu.mutation.MainCategory(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldMainCategory,
		})
	}
	if tu.mutation.MainCategoryCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldMainCategory,
		})
	}
	if value, ok := tu.mutation.SubCategory(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldSubCategory,
		})
	}
	if tu.mutation.SubCategoryCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldSubCategory,
		})
	}
	if value, ok := tu.mutation.CheckNumber(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldCheckNumber,
		})
	}
	if tu.mutation.CheckNumberCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldCheckNumber,
		})
	}
	if value, ok := tu.mutation.Latitude(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLatitude,
		})
	}
	if value, ok := tu.mutation.AddedLatitude(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLatitude,
		})
	}
	if tu.mutation.LatitudeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldLatitude,
		})
	}
	if value, ok := tu.mutation.Longitude(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLongitude,
		})
	}
	if value, ok := tu.mutation.AddedLongitude(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLongitude,
		})
	}
	if tu.mutation.LongitudeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldLongitude,
		})
	}
	if value, ok := tu.mutation.MerchantCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldMerchantCode,
		})
	}
	if tu.mutation.MerchantCodeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldMerchantCode,
		})
	}
	if value, ok := tu.mutation.Reversal(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: transaction.FieldReversal,
		})
	}
	if value, ok := tu.mutation.ReversalFor(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldReversalFor,
		})
	}
	if tu.mutation.ReversalForCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldReversalFor,
		})
	}
	if value, ok := tu.mutation.Reversed(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: transaction.FieldReversed,
		})
	}
	if value, ok := tu.mutation.ReversedBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldReversedBy,
		})
	}
	if tu.mutation.ReversedByCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldReversedBy,
		})
	}
	if value, ok := tu.mutation.URL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldURL,
		})
	}
	if tu.mutation.URLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldURL,
		})
	}
	if tu.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.ImagesTable,
			Columns: []string{transaction.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: binaryitem.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedImagesIDs(); len(nodes) > 0 && !tu.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.ImagesTable,
			Columns: []string{transaction.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: binaryitem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.ImagesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.ImagesTable,
			Columns: []string{transaction.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: binaryitem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, tu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{transaction.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// TransactionUpdateOne is the builder for updating a single Transaction entity.
type TransactionUpdateOne struct {
	config
	hooks    []Hook
	mutation *TransactionMutation
}

// SetSequenceInDay sets the "sequenceInDay" field.
func (tuo *TransactionUpdateOne) SetSequenceInDay(i int) *TransactionUpdateOne {
	tuo.mutation.ResetSequenceInDay()
	tuo.mutation.SetSequenceInDay(i)
	return tuo
}

// SetNillableSequenceInDay sets the "sequenceInDay" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableSequenceInDay(i *int) *TransactionUpdateOne {
	if i != nil {
		tuo.SetSequenceInDay(*i)
	}
	return tuo
}

// AddSequenceInDay adds i to the "sequenceInDay" field.
func (tuo *TransactionUpdateOne) AddSequenceInDay(i int) *TransactionUpdateOne {
	tuo.mutation.AddSequenceInDay(i)
	return tuo
}

// ClearSequenceInDay clears the value of the "sequenceInDay" field.
func (tuo *TransactionUpdateOne) ClearSequenceInDay() *TransactionUpdateOne {
	tuo.mutation.ClearSequenceInDay()
	return tuo
}

// SetStatus sets the "status" field.
func (tuo *TransactionUpdateOne) SetStatus(t transaction.Status) *TransactionUpdateOne {
	tuo.mutation.SetStatus(t)
	return tuo
}

// SetExecutedAmount sets the "executedAmount" field.
func (tuo *TransactionUpdateOne) SetExecutedAmount(f float64) *TransactionUpdateOne {
	tuo.mutation.ResetExecutedAmount()
	tuo.mutation.SetExecutedAmount(f)
	return tuo
}

// AddExecutedAmount adds f to the "executedAmount" field.
func (tuo *TransactionUpdateOne) AddExecutedAmount(f float64) *TransactionUpdateOne {
	tuo.mutation.AddExecutedAmount(f)
	return tuo
}

// SetExecutedCurrencyCode sets the "executedCurrencyCode" field.
func (tuo *TransactionUpdateOne) SetExecutedCurrencyCode(s string) *TransactionUpdateOne {
	tuo.mutation.SetExecutedCurrencyCode(s)
	return tuo
}

// SetExchangeRate sets the "exchangeRate" field.
func (tuo *TransactionUpdateOne) SetExchangeRate(f float64) *TransactionUpdateOne {
	tuo.mutation.ResetExchangeRate()
	tuo.mutation.SetExchangeRate(f)
	return tuo
}

// SetNillableExchangeRate sets the "exchangeRate" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableExchangeRate(f *float64) *TransactionUpdateOne {
	if f != nil {
		tuo.SetExchangeRate(*f)
	}
	return tuo
}

// AddExchangeRate adds f to the "exchangeRate" field.
func (tuo *TransactionUpdateOne) AddExchangeRate(f float64) *TransactionUpdateOne {
	tuo.mutation.AddExchangeRate(f)
	return tuo
}

// ClearExchangeRate clears the value of the "exchangeRate" field.
func (tuo *TransactionUpdateOne) ClearExchangeRate() *TransactionUpdateOne {
	tuo.mutation.ClearExchangeRate()
	return tuo
}

// SetOriginatingAmount sets the "originatingAmount" field.
func (tuo *TransactionUpdateOne) SetOriginatingAmount(f float64) *TransactionUpdateOne {
	tuo.mutation.ResetOriginatingAmount()
	tuo.mutation.SetOriginatingAmount(f)
	return tuo
}

// SetNillableOriginatingAmount sets the "originatingAmount" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableOriginatingAmount(f *float64) *TransactionUpdateOne {
	if f != nil {
		tuo.SetOriginatingAmount(*f)
	}
	return tuo
}

// AddOriginatingAmount adds f to the "originatingAmount" field.
func (tuo *TransactionUpdateOne) AddOriginatingAmount(f float64) *TransactionUpdateOne {
	tuo.mutation.AddOriginatingAmount(f)
	return tuo
}

// ClearOriginatingAmount clears the value of the "originatingAmount" field.
func (tuo *TransactionUpdateOne) ClearOriginatingAmount() *TransactionUpdateOne {
	tuo.mutation.ClearOriginatingAmount()
	return tuo
}

// SetOriginatingCurrencyCode sets the "originatingCurrencyCode" field.
func (tuo *TransactionUpdateOne) SetOriginatingCurrencyCode(s string) *TransactionUpdateOne {
	tuo.mutation.SetOriginatingCurrencyCode(s)
	return tuo
}

// SetNillableOriginatingCurrencyCode sets the "originatingCurrencyCode" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableOriginatingCurrencyCode(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetOriginatingCurrencyCode(*s)
	}
	return tuo
}

// ClearOriginatingCurrencyCode clears the value of the "originatingCurrencyCode" field.
func (tuo *TransactionUpdateOne) ClearOriginatingCurrencyCode() *TransactionUpdateOne {
	tuo.mutation.ClearOriginatingCurrencyCode()
	return tuo
}

// SetDirection sets the "direction" field.
func (tuo *TransactionUpdateOne) SetDirection(t transaction.Direction) *TransactionUpdateOne {
	tuo.mutation.SetDirection(t)
	return tuo
}

// SetRunningBalance sets the "runningBalance" field.
func (tuo *TransactionUpdateOne) SetRunningBalance(f float64) *TransactionUpdateOne {
	tuo.mutation.ResetRunningBalance()
	tuo.mutation.SetRunningBalance(f)
	return tuo
}

// AddRunningBalance adds f to the "runningBalance" field.
func (tuo *TransactionUpdateOne) AddRunningBalance(f float64) *TransactionUpdateOne {
	tuo.mutation.AddRunningBalance(f)
	return tuo
}

// SetCreatedDate sets the "createdDate" field.
func (tuo *TransactionUpdateOne) SetCreatedDate(t time.Time) *TransactionUpdateOne {
	tuo.mutation.SetCreatedDate(t)
	return tuo
}

// SetPostedDate sets the "postedDate" field.
func (tuo *TransactionUpdateOne) SetPostedDate(t time.Time) *TransactionUpdateOne {
	tuo.mutation.SetPostedDate(t)
	return tuo
}

// SetNillablePostedDate sets the "postedDate" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillablePostedDate(t *time.Time) *TransactionUpdateOne {
	if t != nil {
		tuo.SetPostedDate(*t)
	}
	return tuo
}

// ClearPostedDate clears the value of the "postedDate" field.
func (tuo *TransactionUpdateOne) ClearPostedDate() *TransactionUpdateOne {
	tuo.mutation.ClearPostedDate()
	return tuo
}

// SetExecutedDate sets the "executedDate" field.
func (tuo *TransactionUpdateOne) SetExecutedDate(t time.Time) *TransactionUpdateOne {
	tuo.mutation.SetExecutedDate(t)
	return tuo
}

// SetNillableExecutedDate sets the "executedDate" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableExecutedDate(t *time.Time) *TransactionUpdateOne {
	if t != nil {
		tuo.SetExecutedDate(*t)
	}
	return tuo
}

// ClearExecutedDate clears the value of the "executedDate" field.
func (tuo *TransactionUpdateOne) ClearExecutedDate() *TransactionUpdateOne {
	tuo.mutation.ClearExecutedDate()
	return tuo
}

// SetUpdatedDate sets the "updatedDate" field.
func (tuo *TransactionUpdateOne) SetUpdatedDate(t time.Time) *TransactionUpdateOne {
	tuo.mutation.SetUpdatedDate(t)
	return tuo
}

// SetNillableUpdatedDate sets the "updatedDate" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableUpdatedDate(t *time.Time) *TransactionUpdateOne {
	if t != nil {
		tuo.SetUpdatedDate(*t)
	}
	return tuo
}

// ClearUpdatedDate clears the value of the "updatedDate" field.
func (tuo *TransactionUpdateOne) ClearUpdatedDate() *TransactionUpdateOne {
	tuo.mutation.ClearUpdatedDate()
	return tuo
}

// SetDescription sets the "description" field.
func (tuo *TransactionUpdateOne) SetDescription(s string) *TransactionUpdateOne {
	tuo.mutation.SetDescription(s)
	return tuo
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableDescription(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetDescription(*s)
	}
	return tuo
}

// ClearDescription clears the value of the "description" field.
func (tuo *TransactionUpdateOne) ClearDescription() *TransactionUpdateOne {
	tuo.mutation.ClearDescription()
	return tuo
}

// SetMemo sets the "memo" field.
func (tuo *TransactionUpdateOne) SetMemo(s string) *TransactionUpdateOne {
	tuo.mutation.SetMemo(s)
	return tuo
}

// SetNillableMemo sets the "memo" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableMemo(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetMemo(*s)
	}
	return tuo
}

// ClearMemo clears the value of the "memo" field.
func (tuo *TransactionUpdateOne) ClearMemo() *TransactionUpdateOne {
	tuo.mutation.ClearMemo()
	return tuo
}

// SetGroup sets the "group" field.
func (tuo *TransactionUpdateOne) SetGroup(s string) *TransactionUpdateOne {
	tuo.mutation.SetGroup(s)
	return tuo
}

// SetNillableGroup sets the "group" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableGroup(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetGroup(*s)
	}
	return tuo
}

// ClearGroup clears the value of the "group" field.
func (tuo *TransactionUpdateOne) ClearGroup() *TransactionUpdateOne {
	tuo.mutation.ClearGroup()
	return tuo
}

// SetType sets the "type" field.
func (tuo *TransactionUpdateOne) SetType(s string) *TransactionUpdateOne {
	tuo.mutation.SetType(s)
	return tuo
}

// SetNillableType sets the "type" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableType(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetType(*s)
	}
	return tuo
}

// ClearType clears the value of the "type" field.
func (tuo *TransactionUpdateOne) ClearType() *TransactionUpdateOne {
	tuo.mutation.ClearType()
	return tuo
}

// SetMainCategory sets the "mainCategory" field.
func (tuo *TransactionUpdateOne) SetMainCategory(s string) *TransactionUpdateOne {
	tuo.mutation.SetMainCategory(s)
	return tuo
}

// SetNillableMainCategory sets the "mainCategory" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableMainCategory(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetMainCategory(*s)
	}
	return tuo
}

// ClearMainCategory clears the value of the "mainCategory" field.
func (tuo *TransactionUpdateOne) ClearMainCategory() *TransactionUpdateOne {
	tuo.mutation.ClearMainCategory()
	return tuo
}

// SetSubCategory sets the "subCategory" field.
func (tuo *TransactionUpdateOne) SetSubCategory(s string) *TransactionUpdateOne {
	tuo.mutation.SetSubCategory(s)
	return tuo
}

// SetNillableSubCategory sets the "subCategory" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableSubCategory(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetSubCategory(*s)
	}
	return tuo
}

// ClearSubCategory clears the value of the "subCategory" field.
func (tuo *TransactionUpdateOne) ClearSubCategory() *TransactionUpdateOne {
	tuo.mutation.ClearSubCategory()
	return tuo
}

// SetCheckNumber sets the "checkNumber" field.
func (tuo *TransactionUpdateOne) SetCheckNumber(s string) *TransactionUpdateOne {
	tuo.mutation.SetCheckNumber(s)
	return tuo
}

// SetNillableCheckNumber sets the "checkNumber" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableCheckNumber(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetCheckNumber(*s)
	}
	return tuo
}

// ClearCheckNumber clears the value of the "checkNumber" field.
func (tuo *TransactionUpdateOne) ClearCheckNumber() *TransactionUpdateOne {
	tuo.mutation.ClearCheckNumber()
	return tuo
}

// SetLatitude sets the "latitude" field.
func (tuo *TransactionUpdateOne) SetLatitude(f float64) *TransactionUpdateOne {
	tuo.mutation.ResetLatitude()
	tuo.mutation.SetLatitude(f)
	return tuo
}

// SetNillableLatitude sets the "latitude" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableLatitude(f *float64) *TransactionUpdateOne {
	if f != nil {
		tuo.SetLatitude(*f)
	}
	return tuo
}

// AddLatitude adds f to the "latitude" field.
func (tuo *TransactionUpdateOne) AddLatitude(f float64) *TransactionUpdateOne {
	tuo.mutation.AddLatitude(f)
	return tuo
}

// ClearLatitude clears the value of the "latitude" field.
func (tuo *TransactionUpdateOne) ClearLatitude() *TransactionUpdateOne {
	tuo.mutation.ClearLatitude()
	return tuo
}

// SetLongitude sets the "longitude" field.
func (tuo *TransactionUpdateOne) SetLongitude(f float64) *TransactionUpdateOne {
	tuo.mutation.ResetLongitude()
	tuo.mutation.SetLongitude(f)
	return tuo
}

// SetNillableLongitude sets the "longitude" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableLongitude(f *float64) *TransactionUpdateOne {
	if f != nil {
		tuo.SetLongitude(*f)
	}
	return tuo
}

// AddLongitude adds f to the "longitude" field.
func (tuo *TransactionUpdateOne) AddLongitude(f float64) *TransactionUpdateOne {
	tuo.mutation.AddLongitude(f)
	return tuo
}

// ClearLongitude clears the value of the "longitude" field.
func (tuo *TransactionUpdateOne) ClearLongitude() *TransactionUpdateOne {
	tuo.mutation.ClearLongitude()
	return tuo
}

// SetMerchantCode sets the "merchantCode" field.
func (tuo *TransactionUpdateOne) SetMerchantCode(s string) *TransactionUpdateOne {
	tuo.mutation.SetMerchantCode(s)
	return tuo
}

// SetNillableMerchantCode sets the "merchantCode" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableMerchantCode(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetMerchantCode(*s)
	}
	return tuo
}

// ClearMerchantCode clears the value of the "merchantCode" field.
func (tuo *TransactionUpdateOne) ClearMerchantCode() *TransactionUpdateOne {
	tuo.mutation.ClearMerchantCode()
	return tuo
}

// SetReversal sets the "reversal" field.
func (tuo *TransactionUpdateOne) SetReversal(b bool) *TransactionUpdateOne {
	tuo.mutation.SetReversal(b)
	return tuo
}

// SetReversalFor sets the "reversalFor" field.
func (tuo *TransactionUpdateOne) SetReversalFor(s string) *TransactionUpdateOne {
	tuo.mutation.SetReversalFor(s)
	return tuo
}

// SetNillableReversalFor sets the "reversalFor" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableReversalFor(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetReversalFor(*s)
	}
	return tuo
}

// ClearReversalFor clears the value of the "reversalFor" field.
func (tuo *TransactionUpdateOne) ClearReversalFor() *TransactionUpdateOne {
	tuo.mutation.ClearReversalFor()
	return tuo
}

// SetReversed sets the "reversed" field.
func (tuo *TransactionUpdateOne) SetReversed(b bool) *TransactionUpdateOne {
	tuo.mutation.SetReversed(b)
	return tuo
}

// SetReversedBy sets the "reversedBy" field.
func (tuo *TransactionUpdateOne) SetReversedBy(s string) *TransactionUpdateOne {
	tuo.mutation.SetReversedBy(s)
	return tuo
}

// SetNillableReversedBy sets the "reversedBy" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableReversedBy(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetReversedBy(*s)
	}
	return tuo
}

// ClearReversedBy clears the value of the "reversedBy" field.
func (tuo *TransactionUpdateOne) ClearReversedBy() *TransactionUpdateOne {
	tuo.mutation.ClearReversedBy()
	return tuo
}

// SetURL sets the "url" field.
func (tuo *TransactionUpdateOne) SetURL(s string) *TransactionUpdateOne {
	tuo.mutation.SetURL(s)
	return tuo
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (tuo *TransactionUpdateOne) SetNillableURL(s *string) *TransactionUpdateOne {
	if s != nil {
		tuo.SetURL(*s)
	}
	return tuo
}

// ClearURL clears the value of the "url" field.
func (tuo *TransactionUpdateOne) ClearURL() *TransactionUpdateOne {
	tuo.mutation.ClearURL()
	return tuo
}

// AddImageIDs adds the "images" edge to the BinaryItem entity by IDs.
func (tuo *TransactionUpdateOne) AddImageIDs(ids ...int) *TransactionUpdateOne {
	tuo.mutation.AddImageIDs(ids...)
	return tuo
}

// AddImages adds the "images" edges to the BinaryItem entity.
func (tuo *TransactionUpdateOne) AddImages(b ...*BinaryItem) *TransactionUpdateOne {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return tuo.AddImageIDs(ids...)
}

// Mutation returns the TransactionMutation object of the builder.
func (tuo *TransactionUpdateOne) Mutation() *TransactionMutation {
	return tuo.mutation
}

// ClearImages clears all "images" edges to the BinaryItem entity.
func (tuo *TransactionUpdateOne) ClearImages() *TransactionUpdateOne {
	tuo.mutation.ClearImages()
	return tuo
}

// RemoveImageIDs removes the "images" edge to BinaryItem entities by IDs.
func (tuo *TransactionUpdateOne) RemoveImageIDs(ids ...int) *TransactionUpdateOne {
	tuo.mutation.RemoveImageIDs(ids...)
	return tuo
}

// RemoveImages removes "images" edges to BinaryItem entities.
func (tuo *TransactionUpdateOne) RemoveImages(b ...*BinaryItem) *TransactionUpdateOne {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return tuo.RemoveImageIDs(ids...)
}

// Save executes the query and returns the updated Transaction entity.
func (tuo *TransactionUpdateOne) Save(ctx context.Context) (*Transaction, error) {
	var (
		err  error
		node *Transaction
	)
	if len(tuo.hooks) == 0 {
		if err = tuo.check(); err != nil {
			return nil, err
		}
		node, err = tuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*TransactionMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = tuo.check(); err != nil {
				return nil, err
			}
			tuo.mutation = mutation
			node, err = tuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(tuo.hooks) - 1; i >= 0; i-- {
			mut = tuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, tuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (tuo *TransactionUpdateOne) SaveX(ctx context.Context) *Transaction {
	node, err := tuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (tuo *TransactionUpdateOne) Exec(ctx context.Context) error {
	_, err := tuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tuo *TransactionUpdateOne) ExecX(ctx context.Context) {
	if err := tuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tuo *TransactionUpdateOne) check() error {
	if v, ok := tuo.mutation.Status(); ok {
		if err := transaction.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf("ent: validator failed for field \"status\": %w", err)}
		}
	}
	if v, ok := tuo.mutation.ExecutedCurrencyCode(); ok {
		if err := transaction.ExecutedCurrencyCodeValidator(v); err != nil {
			return &ValidationError{Name: "executedCurrencyCode", err: fmt.Errorf("ent: validator failed for field \"executedCurrencyCode\": %w", err)}
		}
	}
	if v, ok := tuo.mutation.OriginatingCurrencyCode(); ok {
		if err := transaction.OriginatingCurrencyCodeValidator(v); err != nil {
			return &ValidationError{Name: "originatingCurrencyCode", err: fmt.Errorf("ent: validator failed for field \"originatingCurrencyCode\": %w", err)}
		}
	}
	if v, ok := tuo.mutation.Direction(); ok {
		if err := transaction.DirectionValidator(v); err != nil {
			return &ValidationError{Name: "direction", err: fmt.Errorf("ent: validator failed for field \"direction\": %w", err)}
		}
	}
	return nil
}

func (tuo *TransactionUpdateOne) sqlSave(ctx context.Context) (_node *Transaction, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   transaction.Table,
			Columns: transaction.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: transaction.FieldID,
			},
		},
	}
	id, ok := tuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing Transaction.ID for update")}
	}
	_spec.Node.ID.Value = id
	if ps := tuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tuo.mutation.SequenceInDay(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: transaction.FieldSequenceInDay,
		})
	}
	if value, ok := tuo.mutation.AddedSequenceInDay(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: transaction.FieldSequenceInDay,
		})
	}
	if tuo.mutation.SequenceInDayCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: transaction.FieldSequenceInDay,
		})
	}
	if value, ok := tuo.mutation.Status(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: transaction.FieldStatus,
		})
	}
	if value, ok := tuo.mutation.ExecutedAmount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExecutedAmount,
		})
	}
	if value, ok := tuo.mutation.AddedExecutedAmount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExecutedAmount,
		})
	}
	if value, ok := tuo.mutation.ExecutedCurrencyCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldExecutedCurrencyCode,
		})
	}
	if value, ok := tuo.mutation.ExchangeRate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExchangeRate,
		})
	}
	if value, ok := tuo.mutation.AddedExchangeRate(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldExchangeRate,
		})
	}
	if tuo.mutation.ExchangeRateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldExchangeRate,
		})
	}
	if value, ok := tuo.mutation.OriginatingAmount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldOriginatingAmount,
		})
	}
	if value, ok := tuo.mutation.AddedOriginatingAmount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldOriginatingAmount,
		})
	}
	if tuo.mutation.OriginatingAmountCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldOriginatingAmount,
		})
	}
	if value, ok := tuo.mutation.OriginatingCurrencyCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldOriginatingCurrencyCode,
		})
	}
	if tuo.mutation.OriginatingCurrencyCodeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldOriginatingCurrencyCode,
		})
	}
	if value, ok := tuo.mutation.Direction(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: transaction.FieldDirection,
		})
	}
	if value, ok := tuo.mutation.RunningBalance(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldRunningBalance,
		})
	}
	if value, ok := tuo.mutation.AddedRunningBalance(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldRunningBalance,
		})
	}
	if value, ok := tuo.mutation.CreatedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldCreatedDate,
		})
	}
	if value, ok := tuo.mutation.PostedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldPostedDate,
		})
	}
	if tuo.mutation.PostedDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: transaction.FieldPostedDate,
		})
	}
	if value, ok := tuo.mutation.ExecutedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldExecutedDate,
		})
	}
	if tuo.mutation.ExecutedDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: transaction.FieldExecutedDate,
		})
	}
	if value, ok := tuo.mutation.UpdatedDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: transaction.FieldUpdatedDate,
		})
	}
	if tuo.mutation.UpdatedDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: transaction.FieldUpdatedDate,
		})
	}
	if value, ok := tuo.mutation.Description(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldDescription,
		})
	}
	if tuo.mutation.DescriptionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldDescription,
		})
	}
	if value, ok := tuo.mutation.Memo(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldMemo,
		})
	}
	if tuo.mutation.MemoCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldMemo,
		})
	}
	if value, ok := tuo.mutation.Group(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldGroup,
		})
	}
	if tuo.mutation.GroupCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldGroup,
		})
	}
	if value, ok := tuo.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldType,
		})
	}
	if tuo.mutation.TypeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldType,
		})
	}
	if value, ok := tuo.mutation.MainCategory(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldMainCategory,
		})
	}
	if tuo.mutation.MainCategoryCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldMainCategory,
		})
	}
	if value, ok := tuo.mutation.SubCategory(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldSubCategory,
		})
	}
	if tuo.mutation.SubCategoryCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldSubCategory,
		})
	}
	if value, ok := tuo.mutation.CheckNumber(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldCheckNumber,
		})
	}
	if tuo.mutation.CheckNumberCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldCheckNumber,
		})
	}
	if value, ok := tuo.mutation.Latitude(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLatitude,
		})
	}
	if value, ok := tuo.mutation.AddedLatitude(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLatitude,
		})
	}
	if tuo.mutation.LatitudeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldLatitude,
		})
	}
	if value, ok := tuo.mutation.Longitude(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLongitude,
		})
	}
	if value, ok := tuo.mutation.AddedLongitude(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: transaction.FieldLongitude,
		})
	}
	if tuo.mutation.LongitudeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Column: transaction.FieldLongitude,
		})
	}
	if value, ok := tuo.mutation.MerchantCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldMerchantCode,
		})
	}
	if tuo.mutation.MerchantCodeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldMerchantCode,
		})
	}
	if value, ok := tuo.mutation.Reversal(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: transaction.FieldReversal,
		})
	}
	if value, ok := tuo.mutation.ReversalFor(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldReversalFor,
		})
	}
	if tuo.mutation.ReversalForCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldReversalFor,
		})
	}
	if value, ok := tuo.mutation.Reversed(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: transaction.FieldReversed,
		})
	}
	if value, ok := tuo.mutation.ReversedBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldReversedBy,
		})
	}
	if tuo.mutation.ReversedByCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldReversedBy,
		})
	}
	if value, ok := tuo.mutation.URL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: transaction.FieldURL,
		})
	}
	if tuo.mutation.URLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: transaction.FieldURL,
		})
	}
	if tuo.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.ImagesTable,
			Columns: []string{transaction.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: binaryitem.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedImagesIDs(); len(nodes) > 0 && !tuo.mutation.ImagesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.ImagesTable,
			Columns: []string{transaction.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: binaryitem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.ImagesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   transaction.ImagesTable,
			Columns: []string{transaction.ImagesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: binaryitem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Transaction{config: tuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, tuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{transaction.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
