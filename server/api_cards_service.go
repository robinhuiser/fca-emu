/*
 * Cloud API
 *
 * The public facing API through which connectors are exposed as a single abtract API
 *
 * API version: v1.5
 * Contact: support@trexis.net
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package finite

import (
	"context"
	"fmt"
	"strconv"

	"github.com/google/uuid"
	"github.com/robinhuiser/fca-emu/ent"
	"github.com/robinhuiser/fca-emu/ent/account"
	"github.com/robinhuiser/fca-emu/util"
)

// CardsApiService is a service that implents the logic for the CardsApiServicer
// This service should implement the business logic for every endpoint for the CardsApi API.
// Include any external packages or services that will be required by this service.
type CardsApiService struct {
}

// NewCardsApiService creates a default api service
func NewCardsApiService() CardsApiServicer {
	return &CardsApiService{}
}

// GetAccountCards - Return a accounts cards
func (s *CardsApiService) GetAccountCards(ctx context.Context, accountId string, mask bool, enhance bool, xTRACEID string, xTOKEN string) (ImplResponse, error) {
	// Validate X-Token
	if !isValidSecret(xTOKEN) {
		return Response(401, setErrorResponse("Invalid token")), nil
	}

	// Parse and verify UUID
	ua, err := uuid.Parse(accountId)
	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the account
	rs, err := clt.Account.
		Query().
		Where(account.ID(ua)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Retrieve the cards
	crds, err := rs.QueryCards().All(ctx)
	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}
	if len(crds) == 0 {
		return Response(404, setErrorResponse("No cards found")), nil
	}

	cards := []Card{}
	for _, crd := range crds {
		card, err := mapCard(rs, crd, mask, enhance, ctx)
		if err != nil {
			return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
		}
		cards = append(cards, card)
	}

	c := CardsList{
		Status:     true,
		TotalItems: int32(len(crds)),
		Cards:      cards,
	}

	return Response(200, c), nil
}

func mapCard(acct *ent.Account, crd *ent.Card, mask bool, en bool, ctx context.Context) (Card, error) {

	cn, err := crd.QueryNetwork().Only(ctx)
	if err != nil {
		return Card{}, fmt.Errorf("%v", err)
	}

	c := Card{
		Id:         strconv.Itoa(crd.ID),
		Type:       crd.Type.String(),
		Number:     isMasked(mask, crd.Number),
		StartDate:  isValidBankDate(crd.StartDate.Format(util.APIDateFormat)),
		ExpiryDate: isValidBankDate(crd.ExpiryDate.Format(util.APIDateFormat)),
		HolderName: crd.HolderName,
		Network:    cn.Name,
		Status:     string(crd.Status),
		URI: FiniteUri{
			URL: crd.URL,
		},
	}

	return c, nil
}
