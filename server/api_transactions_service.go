/*
 * Cloud API
 *
 * The public facing API through which connectors are exposed as a single abtract API
 *
 * API version: v1.5
 * Contact: support@trexis.net
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package finite

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/robinhuiser/fca-emu/ent"
	"github.com/robinhuiser/fca-emu/ent/account"
	"github.com/robinhuiser/fca-emu/ent/binaryitem"
	"github.com/robinhuiser/fca-emu/ent/transaction"
)

// TransactionsApiService is a service that implents the logic for the TransactionsApiServicer
// This service should implement the business logic for every endpoint for the TransactionsApi API.
// Include any external packages or services that will be required by this service.
type TransactionsApiService struct {
}

// NewTransactionsApiService creates a default api service
func NewTransactionsApiService() TransactionsApiServicer {
	return &TransactionsApiService{}
}

// GetAccountTransaction - Return a given accounts transaction
func (s *TransactionsApiService) GetAccountTransaction(ctx context.Context, accountId string, transactionId string, mask bool, inline bool, enhance bool, xTRACEID string, xTOKEN string) (ImplResponse, error) {
	// Validate X-Token
	if !isValidSecret(xTOKEN) {
		return Response(401, setErrorResponse(INVALID_TOKEN_MSG)), nil
	}

	// Parse and verify UUID
	ua, err := uuid.Parse(accountId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse and verify UUID
	ut, err := uuid.Parse(transactionId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the account
	rs, err := clt.Account.
		Query().
		Where(account.ID(ua)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Retrieve the transaction
	tr, err := rs.QueryTransactions().Where(transaction.ID(ut)).Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse("Transaction not found")), nil
	}

	tran, err := mapTransaction(rs, tr, mask, enhance, inline, ctx)
	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	return Response(200, tran), nil
}

// GetAccountTransactionImage - Return a given image
func (s *TransactionsApiService) GetAccountTransactionImage(ctx context.Context, accountId string, itemId string, xTRACEID string, xTOKEN string) (ImplResponse, error) {
	// Validate X-Token
	if !isValidSecret(xTOKEN) {
		return Response(401, setErrorResponse(INVALID_TOKEN_MSG)), nil
	}

	// Parse and verify UUID
	ua, err := uuid.Parse(accountId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse and validate itemId
	i, err := strconv.Atoi(itemId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the account
	_, err = clt.Account.
		Query().
		Where(account.ID(ua)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the image
	img, err := clt.BinaryItem.
		Query().
		Where(binaryitem.ID(i)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Verify if the image belongs to a transaction of the provided account
	tr, err := img.QueryTransaction().Only(ctx)
	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	ac, err := tr.QueryAccount().Only(ctx)
	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	if ac.ID != ua {
		return Response(400, setErrorResponse("Image does not belong to account")), nil
	}

	return Response(200, img.Content), nil
}

// GetAccountTransactionImages - Return the binary images for a given transaction
func (s *TransactionsApiService) GetAccountTransactionImages(ctx context.Context, accountId string, transactionId string, mask bool, inline bool, enhance bool, xTRACEID string, xTOKEN string) (ImplResponse, error) {
	// Validate X-Token
	if !isValidSecret(xTOKEN) {
		return Response(401, setErrorResponse(INVALID_TOKEN_MSG)), nil
	}

	// Parse and verify UUID
	ua, err := uuid.Parse(accountId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse and verify UUID
	ut, err := uuid.Parse(transactionId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the account
	rs, err := clt.Account.
		Query().
		Where(account.ID(ua)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Retrieve the transaction
	tr, err := rs.QueryTransactions().Where(transaction.ID(ut)).Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse("Transaction not found")), nil
	}

	imgs, err := tr.QueryImages().All(ctx)
	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}
	imageList := getTransactionImages(imgs, inline)

	return Response(200, imageList), nil
}

// GetAccountTransactions - Return a accounts transactions
func (s *TransactionsApiService) GetAccountTransactions(ctx context.Context, accountId string, mask bool, startDateTime string, endDateTime string, reversedInRunning bool, limit int32, cursor string, status TransactionStatus, enhance bool, xTRACEID string, xTOKEN string) (ImplResponse, error) {
	// Validate X-Token
	if !isValidSecret(xTOKEN) {
		return Response(401, setErrorResponse(INVALID_TOKEN_MSG)), nil
	}

	// Parse and verify UUID
	u, err := uuid.Parse(accountId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the account
	rs, err := clt.Account.
		Query().
		Where(account.ID(u)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse limit
	maxresults := parseLimit(limit)

	// Parse cursor
	offset, err := parseCursor(cursor)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse dates
	sDate, err := parseFilterDate(rs.DateCreated, startDateTime)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	eDate, err := parseFilterDate(time.Now(), endDateTime)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse transaction status
	stat, err := setTransactionStatusFilter(status)
	if err != nil {
		return Response(400, setErrorResponse("Invalid transaction status")), nil
	}

	// Retrieve the transactions
	trs, err := rs.QueryTransactions().
		Offset(offset).
		Limit(maxresults).
		Where(
			transaction.And(
				transaction.CreatedDateGTE(sDate),
				transaction.CreatedDateLTE(eDate),
				transaction.StatusIn(stat...),
			),
		).Order(ent.Desc(transaction.FieldCreatedDate)).
		All(ctx)

	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}
	if len(trs) == 0 {
		return Response(404, setErrorResponse("No (more) transactions found")), nil
	}

	transactions := []Transaction{}
	for _, tr := range trs {
		tran, err := mapTransaction(rs, tr, mask, enhance, false, ctx)
		if err != nil {
			return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
		}
		transactions = append(transactions, tran)
	}

	t := TransactionsList{
		Status:       true,
		TotalItems:   int32(len(trs)),
		NextCursor:   base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(len(trs) + offset))),
		Transactions: transactions,
	}

	return Response(200, t), nil
}

// SearchTransactions - Search for transactions
func (s *TransactionsApiService) SearchTransactions(ctx context.Context, accountId string, limit int32, cursor string, mask bool, enhance bool, xTRACEID string, xTOKEN string, searchFilter []SearchFilter) (ImplResponse, error) {

	// Validate X-Token
	if !isValidSecret(xTOKEN) {
		return Response(401, setErrorResponse(INVALID_TOKEN_MSG)), nil
	}

	// Parse limit
	maxresults := parseLimit(limit)

	// Parse cursor
	offset, err := parseCursor(cursor)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Parse and verify UUID
	u, err := uuid.Parse(accountId)
	if err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Validate searchFilter
	if err := validatePredicate(searchFilter); err != nil {
		return Response(400, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Lookup the account
	rs, err := clt.Account.
		Query().
		Where(account.ID(u)).
		Only(ctx)
	if err != nil {
		return Response(404, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}

	// Retrieve the transactions
	// CHALLENGE -- construct from searchfilter a WHERE clause
	trs, err := rs.QueryTransactions().
		Offset(offset).
		Limit(maxresults).
		Order(ent.Desc(transaction.FieldCreatedDate)).
		All(ctx)

	if err != nil {
		return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
	}
	if len(trs) == 0 {
		return Response(404, setErrorResponse("No (more) transactions found")), nil
	}

	transactions := []Transaction{}
	for _, tr := range trs {
		tran, err := mapTransaction(rs, tr, mask, enhance, false, ctx)
		if err != nil {
			return Response(500, setErrorResponse(fmt.Sprintf("%v", err))), nil
		}
		transactions = append(transactions, tran)
	}

	t := TransactionsList{
		Status:       true,
		TotalItems:   int32(len(trs)),
		NextCursor:   base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(len(trs) + offset))),
		Transactions: transactions,
	}

	return Response(200, t), nil
}

// Supporting functions
func mapImage(img *ent.BinaryItem, inline bool) BinaryItem {
	return BinaryItem{
		Format: img.Format,
		Length: int32(img.Length),
		ItemId: strconv.Itoa(img.ID),
		URI: FiniteUri{
			URL: img.URL,
		},
		Content: string(inlineContent(inline, img.Content)),
	}
}

func inlineContent(i bool, content []byte) []byte {
	if i {
		return content
	}
	return nil
}

func mapImageList(images []BinaryItem) BinaryItemList {
	return BinaryItemList{
		Status:     true,
		Binaries:   images,
		TotalItems: int32(len(images)),
	}
}

func getTransactionImages(imgs []*ent.BinaryItem, inline bool) BinaryItemList {
	imageList := BinaryItemList{}
	images := []BinaryItem{}

	if len(imgs) > 0 {
		for _, img := range imgs {
			i := mapImage(img, inline)
			images = append(images, i)
		}
		imageList = mapImageList(images)
	}

	return imageList
}

func mapTransaction(acct *ent.Account, tr *ent.Transaction, mask bool, en bool, inline bool, ctx context.Context) (Transaction, error) {

	// Get the entity related to the account
	e, err := acct.QueryOwners().Only(ctx)
	if err != nil {
		return Transaction{}, fmt.Errorf("%v", err)
	}

	// Get  the checks related to the transaction
	imgs, err := tr.QueryImages().All(ctx)
	if err != nil {
		return Transaction{}, fmt.Errorf("%v", err)
	}
	imageList := getTransactionImages(imgs, inline)

	t := Transaction{
		EntityId:                e.ID.String(),
		AccountId:               acct.ID.String(),
		Id:                      tr.ID.String(),
		SequenceInDay:           int32(tr.SequenceInDay),
		Status:                  TransactionStatus(tr.Status),
		ExecutedAmount:          float32(tr.ExecutedAmount),
		ExecutedCurrencyCode:    tr.ExecutedCurrencyCode,
		ExchangeRate:            float32(tr.ExchangeRate),
		OriginatingAmount:       float32(tr.OriginatingAmount),
		OriginatingCurrencyCode: tr.OriginatingCurrencyCode,
		Direction:               tr.Direction.String(),
		RunningBalance:          float32(tr.RunningBalance),
		CreatedDate:             isValidBankDate(tr.CreatedDate.Format(API_DATE_LAYOUT)),
		ExecutedDate:            isValidBankDate(tr.ExecutedDate.Format(API_DATE_LAYOUT)),
		PostedDate:              isValidBankDate(tr.PostedDate.Format(API_DATE_LAYOUT)),
		UpdatedDate:             isValidBankDate(tr.UpdatedDate.Format(API_DATE_LAYOUT)),
		Description:             tr.Description,
		Memo:                    isEnhanced(en, tr.Memo),
		Group:                   isEnhanced(en, tr.Group),
		Type:                    isEnhanced(en, tr.Type),
		MainCategory:            isEnhanced(en, tr.MainCategory),
		SubCategory:             isEnhanced(en, tr.SubCategory),
		CheckNumber:             tr.CheckNumber,
		Images:                  imageList,
		Latitude:                isEnhanced(en, fmt.Sprintf("%f", tr.Latitude)),
		Longitude:               isEnhanced(en, fmt.Sprintf("%f", tr.Longitude)),
		MerchantCode:            isEnhanced(en, tr.MerchantCode),
		Reversal:                tr.Reversal,
		ReversalFor:             tr.ReversalFor,
		Reversed:                tr.Reversed,
		ReversedBy:              tr.ReversedBy,
		Transactor:              Transactor{},
		URI: FiniteUri{
			URL: tr.URL,
		},
	}

	return t, nil
}

func setTransactionStatusFilter(status TransactionStatus) ([]transaction.Status, error) {
	stat := []transaction.Status{transaction.StatusPOSTED, transaction.StatusPENDING}
	if len(status) > 0 {
		switch st := status; st {
		case TransactionStatus(transaction.StatusPOSTED):
			stat = []transaction.Status{transaction.StatusPOSTED}

		case TransactionStatus(transaction.StatusPENDING):
			stat = []transaction.Status{transaction.StatusPENDING}
		default:
			return []transaction.Status{}, fmt.Errorf("%s", "Invalid transaction status")
		}
	}
	return stat, nil
}

func parseFilterDate(d time.Time, pd string) (time.Time, error) {
	if len(pd) > 0 {
		retDate, err := time.Parse(API_DATE_LAYOUT, pd)
		if err != nil {
			return time.Time{}, fmt.Errorf("%v", err)
		}
		d = retDate
	}
	return d, nil
}

func validatePredicate(s []SearchFilter) error {

	return nil
}
